# -*- coding: utf-8 -*-
"""soundClassification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18x5MXWvslI4CIvcFu4NAkpHqP_i37YT4

<h1>Import and Install Dependencies</h1>
"""



import os
from matplotlib import pyplot as plt
import tensorflow as tf
from scipy import signal
import matplotlib.pyplot as plt

"""<h1>Build Data Loading Function</h1>"""

#import data
SCREAMS_FILE = 'C:/Users/Math/Desktop/donne/positive/damm_0.wav'
NON_SCREAMS_FILE = 'C:/Users/Math/Desktop/donne/negative/clnsp1.wav'

tf.config.run_functions_eagerly(True)

#Data loading function
def load_wav_16k_mono(filename):
    # Load encoded wav file
    file_contents = tf.io.read_file(filename)
    # Decode wav (tensors by channels)
    wav, sample_rate = tf.audio.decode_wav(file_contents, desired_channels=1)
    # Removes trailing axis
    #wav = tf.squeeze(wav,axis=-1).numpy().astype('float16')
    #time = len(wav)/sample_rate.numpy()
    #newTime = time*16000
    #newTime = int(newTime)
    #print(newTime)
    #newWav = signal.resample(wav,newTime)
    #finalWav = tf.convert_to_tensor(newWav)
    #wav = tf.squeeze(finalWav,axis=-1)
    #print(finalWav)
    #Goes from 44100Hz to 16000Hz - amplitude of the audio signal
    #wav = 
    return tf.squeeze(wav,axis=-1)

wave = load_wav_16k_mono(SCREAMS_FILE)
nwave = load_wav_16k_mono(NON_SCREAMS_FILE)

plt.plot(wave)
plt.plot(nwave)
plt.show()

"""<h1>Create Tensorflow Dataset</h1>"""

#Paths to positive and negative data
POS = 'C:/Users/Math/Desktop/donne/positive'
NEG = 'C:/Users/Math/Desktop/donne/negative'

#Tenseflow dataset
pos = tf.data.Dataset.list_files(POS+'/*.wav')
neg = tf.data.Dataset.list_files(NEG+'/*.wav')

#Labels and combine
positives = tf.data.Dataset.zip((pos, tf.data.Dataset.from_tensor_slices(tf.ones(len(pos)))))
negatives = tf.data.Dataset.zip((neg, tf.data.Dataset.from_tensor_slices(tf.zeros(len(neg)))))
data = positives.concatenate(negatives)

"""<h1>Determine average length of a scream</h1>"""

#Calculate the average length of a scream/shout
lengths = []
for file in os.listdir('C:/Users/Math/Desktop/donne/positive'):
    tensor_wave = load_wav_16k_mono(os.path.join('/','Users','Math','Desktop','donne','positive',file))
    lengths.append(len(tensor_wave))

"""<h1>Build Preprocessing Function to Convert to Spectrogram</h1>"""

#Preprocessing function
def preprocess (file_path, label):
    wav = load_wav_16k_mono(file_path)
    wav = wav[:120000]
    zero_padding = tf.zeros([120000] - tf.shape(wav), dtype=tf.float32)
    wav = tf.concat([zero_padding,wav],0)
    spectrogram = tf.signal.stft(wav, frame_length=256, frame_step=32)
    spectrogram = tf.abs(spectrogram)
    spectrogram = tf.expand_dims(spectrogram, axis=2)
    return spectrogram, label

"""<h1>Create Training and Testing Partitions</h1>"""

#Tensorflow Data Pipeline
data = data.map(preprocess)
data = data.cache()
data = data.shuffle(buffer_size=1000)
data = data.batch(1)
data = data.prefetch(8)

#Split into Training and Testing Partitions
train = data.take(7)
test = data.skip(7).take(2)

samples, labels = train.as_numpy_iterator().next()

samples.shape

"""<h1>Build Deep Learning Model</h1>

"""

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, Dense, Flatten, MaxPooling2D

#Build Sequential Model, Compile and View Summary
model = tf.keras.Sequential()
model.add(tf.keras.layers.Conv2D(16, (3,3), activation='relu', input_shape=(3743, 129, 1)))
model.add(tf.keras.layers.Conv2D(16, (3,3), activation='relu'))
model.add(tf.keras.layers.Flatten())
model.add(tf.keras.layers.Dense(128, activation='relu'))
model.add(tf.keras.layers.Dense(1, activation='sigmoid'))

model.compile('Adam', loss='BinaryCrossentropy', metrics=[tf.keras.metrics.Recall(),tf.keras.metrics.Precision()])

model.summary()

hist = model.fit(train, epochs=4, validation_data=test)

plt.figure(2)
plt.title('Loss')
plt.plot(hist.history['loss'], 'r')
plt.plot(hist.history['val_loss'], 'b')

plt.figure(1)
plt.title('Precision')
plt.plot(hist.history['precision'], 'r')
plt.plot(hist.history['val_precision'], 'b')

plt.figure(3)
plt.title('Recall')
plt.plot(hist.history['recall'], 'r')
plt.plot(hist.history['val_recall'], 'b')
plt.show()

"""<h1>Make a Prediction on a Single Clip</h1>

"""

#Predictions with examples
X_test, y_test = test.as_numpy_iterator().next()
yhat = model.predict(X_test)

#Sort our predictions
yhat = [1 if prediction > 0.5 else 0 for prediction in yhat]
yhat = []
for prediction in yhat:
    if prediction > 0.5:
        yhat.append(1)
    else:
        yhat.append(0)